# コンソール版 mwx_parser

> ビルドにはgcc,g++などコンパイルコマンド、make/Makefileの知識が必要です。

`mwx_parser`はTWELITE 無線マイコンから出力されるシリアル電文 (アスキー形式) を解釈し、データ構造にアクセスする目的のパーサーです。ここでは一般的な標準入出力を用いたコンソール用のプログラムとしてビルドしています。他のプログラムへの組み込みの参考にしてください。

解釈対象の電文はTWELITE無線マイコンの各アプリ（ファームウェア）より出力されます。複数のアプリからの無線パケットを統合的に受信するApp_Wingsを用いれば複数の種類のアプリを一元的に受信できます。ただし、アプリケーションIDとチャネルは親機・子機・中継機全て同じ設定になっている必要があります。

対応しているTWELITE無線マイコン向けのアプリは以下です。

* App_Twelite 0x81 コマンド
* App_IO
* App_UART
* App_Tag (各センサーの解釈はしません)
* App_PAL (MAG/MOT/AMB)
* App_PAL (NOTICE) イベント形式

実際のデータ例は[App_Wingsの受信メッセージ](https://wings.twelite.info/how-to-use/parent-mode/receive-message)を参考にしてください。



## ファイル構成

```
Makefile     : make によるビルド実行のための定義ファイル

mwx_stdio.sln    : Visual Studio 用のソリューション定義
glancer.vcxproj* : Visual Studio 用のプロジェクト定義 (glancer.cpp)
mini.vcxproj*    : Visual Studio 用のプロジェクト定義 (mini.cpp)

[ソースファイル]
glancer.cpp  : ライブラリ利用コード例１
mini.cpp     : ライブラリ仕様コード例２

[ライブラリファイル]
libsrc       : 標準入出力対応コード
libsrc1      : ライブラリコード (twesettingsから)
libsrc2      : ライブラリコード (mwxから)
printf       : printfライブラリ

[その他]
objs         : オブジェクトファイル
test_msg.txt : テスト用のデータファイル
```



ビルドに必要なライブラリソースは下記の３つです。

* `libsrc`には標準入出力対応のコードや、twesettingsライブラリから引用コード、その他のコードが含まれます。
* `libsrc1`はtwesettingsライブラリソースから必要なファイルをコピーしています。
* `libsrc2`はmwxライブラリソースから必要なファイルをコピーしています。
* `printf`は外部のライブラリソースです。

※ 配布時の`libsrc1`, `libsrc2`のファイルとtwesettings, mwxフォルダ中の同名ファイルの内容が異なる場合があります。これらは独自にメンテナンスされるためですが、本フォルダ中では動作確認した時点でのソースコードのコピーを含めています。



## make, Makefile

makefileの定義で対応する操作について解説します。

| コマンド                  | 内容                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `all`またはパラメータ省略 | mini, glancer サンプルコードのビルドを行います。             |
| `clean`                   | `objs/*` と mini, glancer を消去します。                     |
| `upd-twesettings`         | twesettingsライブラリコード(`../../twesettings`) から必要なファイルを上書きコピーします。 |
| `upd-mwx`                 | mwxライブラリコード(`../`)から必要なファイルを上書きコピーします。 |
| `test`                    | `test_msg.txt`を入力としてコマンドを実行する。               |



### 実行例

```
### 中間ファイル等の削除
$ make clean

### ビルド ###
$ make

###　ライブラリソースを再コピー ###
$ make udp-mwx upd-twesettings

### 全部実行 ###
$ make clean upd-mwx upd-twesettings all test
```



### 定義

| 定義名                      | 内容                                                     |
| --------------------------- | -------------------------------------------------------- |
| APPSRC_CXX                  | コンパイル対象の`.cpp`ファイル                           |
| APPSRC_GLANCER, APPSRC_MINI | コンパイル対象のライブラリ`.cpp`ファイル（アプリ記述）   |
| APPSRC_C                    | コンパイル対象のライブラリ`.c`ファイル                   |
| APPSRC_HPP                  | コンパイル時に参照されるライブラリ`.h`,`.hpp`ファイル    |
| LIB_FILES                   | コンパイル関連の全ライブラリファイルパス                 |
| LIB_MWX_FILES               | mwxライブラリから必要な全ファイル名                      |
| LIB_MWX_FILES_ORIG          | --- オリジナルへの全ファイルパス                         |
| LIB_MWX_FILES_COPY          | --- コピーフォルダ(`libsrc2`)への全ファイルパス          |
| LIB_TWESETTINGS_FILES       | Twesttingsライブラリから必要な全ファイル名               |
| LIB_TWESETTINGS_FILES_ORIG  | --- オリジナルへの全ファイルパス                         |
| LIB_TWESETTINGS_FILES_COPY  | --- コピーフォルダ(`libsrc1`)への全ファイルパス          |
| DEFINES                     | コンパイラに渡す各種定義                                 |
| CFLAGS                      | gcc, g++ コンパイラに渡すフラグ                          |
| CXXFLAGS                    | g++ コンパイラに渡すフラグ                               |
| OSNAME                      | OS種別の判定結果。win, mac, linux のいずれかに設定される |
| CXX                         | g++コンパイラコマンド名                                  |
| CPP                         | gccコンパイラコマンド名                                  |
| OBJDIR                      | コンパイル時の中間ファイルを格納するフォルダ名(`objs`)   |



## Visual Studio用の定義

Visual Studuo用の定義ファイル用意しています。このファイルは配布時の libsrc/libsrc1/libsrc2 のファイルを登録、ビルドできるようにしています。



## glancer.cpp

glancerはglance(一瞥)する人という意味の英単語です。無線パケットの中身を簡易チェックする目的のプログラムです。標準入力に受信メッセージを入力すると解釈結果が表示されます。以下は標準アプリのメッセージを入力した場合です。

```
:78811501C98201015A000391000C2E00810301FFFFFFFFFB[CR][LF]を入力
↓
:78811501C98201015A000391000C2E00810301FFFFFFFFFB
PKT:Typ=1:Lq=201:Ad=0x8201015a(0x78):Vmv=3118:Tms=3360:
  App_Twelite:DI1..4=LHHH:AI1..4=(0028,----,----,----)
```

電文の終わりはCR LF(0x0d 0x0a)と決まっています。解釈されない場合は終端の改行コードが正しく入力されていない可能性があります。以下のように末尾のチェックサムを省略して改行コードの代わりにXを終端とすることもできます。

```
:78811501C98201015A000391000C2E00810301FFFFFFFFXを入力
↓
:78811501C98201015A000391000C2E00810301FFFFFFFFFB
PKT:Typ=1:Lq=201:Ad=0x8201015a(0x78):Vmv=3118:Tms=4895:
  App_Twelite:DI1..4=LHHH:AI1..4=(0028,----,----,----)
```



### ビルド

ソースコードは`glancer.cpp`です。

Makefileを用意していますので、makeコマンドを実行するとコンパイルできます。ただし、gcc のコマンド名など調整が必要な場合があります。

※ macOS の clang/clang++ で確認しています。



### 内部メモリの扱いについて

App_UARTのデータペイロード部や App_PAL のセンサーデータ部などは、`packet_parser` の解釈時に内部にデータコピーを作らず解釈元のバイト配列への参照として取り扱われます。解釈元のデータが改変されると解釈結果が破壊されます。

解釈元のバイト配列に依存しないように、データ部を固定長配列として取り扱うことができます。ただし解釈するデータが固定長サイズより大きい場合は解釈の失敗として取り扱われます。

固定長配列を指定するには以下のマクロ定義を指定します。定義値は確保する配列バイト数です。例えば`-DMWX_PARSER_PKT_APPPAL_FIXED_BUF=32`のようにコンパイルオプションとして指定するとApp_PALのパケット処理の場合、内部的に32バイトの固定配列を確保します。`packet_parser`のサイズはその分大きくなります。ただし32バイトでは例えばMOT PALのFIFOデータは収納できないため解釈エラーになります。

* `MWX_PARSER_PKT_APPUART_FIXED_BUF` : App_UARTのデータペイロード部のサイズ指定
* `MWX_PARSER_PKT_APPPAL_FIXED_BUF` : App_PALのセンサーデータ部（可変長ブロック）はそのまま保持されます。このときの最大バイト数です。
* `MWX_PARSER_PKT_APPTAG_FIXED_BUF` : App_Tagの後半部のセンサーデータ部はそのまま保持されます。このときの最大バイト数です。



## mini.cpp

上述のglancerよりごく短いコードです。glancerに比べてlibsrc/mwx_serial_con.hppで実装したSerialオブジェクトを使用していません。よりコンパクトな記述となっています。

標準入力から`getchar()`で１バイト読み出しパーサー`parser_ser`に逐次投入します。アスキー形式の解釈が終わると`parser_ser.get_buf()`により入力はバイト列に変換されます。このバイト列の種別を`identify_packet_type()`で判別し、標準アプリ用`E_PKT::PKT_TWELITE`である場合、`packet_parser`により解釈を行い同時に`TwePacketTwelite`型を取り出し情報を一部読み取って表示します。



### ビルド

ソースコードは`mini.cpp`で、Makefileにビルドのためのルールが記述されています。

※ macOS の clang/clang++ で確認しています。



## ソースコードについて

以下のようなソースコードが存在します。

* mwx ライブラリのコードをそのまま利用しているもの
* mwx ライブラリの一部であったが変更が多いなど煩雑になるため別ファイルとして作成したもの (libsrc/ フォルダに格納)
* printf ライブラリ (printf/フォルダに格納)
* 環境特有のソースコード (libsrc/mwx_stdio.cpp, mwx_stdio.h)
* メインソース (`loop()`, `setup()`が含まれる)



### 必要な定義について

`TWE_STDINOUT_ONLY`を定義しておく必要があります。この定義はtwe_settings.hpp内部で該当のコンパイル環境の場合設定されています。



### C++言語について

小規模マイコンでのC++を前提とした記述になっています。

* C++11 の構文を用い`template`構文を積極的に利用します
* 仮想関数`virtual`は使用しません
* `new`演算子は原則使用しません（`serparser_heap` といったヒープ領域に内部メモリを確保するクラスを利用する場合もありますが、開放しないことを前提にメモリ確保する使い方です)
* 例外`exception`は使用しません



### mwm5ライブラリのパーサーとの違い

mwm5ライブラリでは、動的メモリ確保が可能である点と、`virtual`による仮想化が可能という２点を前提とした実装になっています。種別ごとに格納内容の異なるデータ型を基底クラスの派生として一元的に取り扱えるようになっています。また`std::shared_ptr<>`を用いることでデータの受け渡しは保管について簡素化しています。つまり基底クラスのコンテナに任意の派生型オブジェクトを格納でき、データが参照されなくなった時点でオブジェクトが破棄`delete`されます。

対してmwxライブラリでは、要求資源が限られるマイコンシステムを想定しているため、静的なメモリ管理が大前提です。解釈結果の一部は解釈前のバイト列を参照するようになっているため、そのままでは解釈結果を永続的に利用できない場合があります。解釈済みのデータを配列などに格納するような場合も、上述の`shared_ptr<>`のような手法は利用できません。

ただし`paket_parser`クラスは簡易的なポリモーフィズムを実現するため、内部に`uint8_t`型の配列を保持し、`TwePacket`クラスの派生クラスオブジェクトを配列上に生成する手法を用いています。`TwePacket`の派生クラスであれば異種のデータ型であっても`packet_parser`クラスに格納できます。



### メインループ

ファイル libsrc/mwx_stdio.hpp, cpp に処理を記述しており `setup()`, `loop()` の処理を行っています。`loop()`は１回毎に `usleep()` により都度スリープして CPU 負荷を低減しています。



### アスキー形式パーサー (serparser_local<>)

アスキー形式 (例 `:00112233X`)をバイナリ列として取り扱うためのパーサークラスです。



### パケットパーサー (packet_parser)

アスキー形式から変換したバイナリ列を解釈し、どの形式のパケットであるが、パケットの内容について解釈し、解釈後のTwePacketオブジェクト (`TwePacketTwelite`など)を生成します。TwePacketオブジェクトはパケット内容を解釈するためのデータ構造となっています。



### Serialオブジェクト

もともとはシリアル通信オブジェクトですが、mwxライブラリを用いたアクト(Act)の記述に近づけるため定義しています。コンソールの入出力として動作します。入力街の処理のためtermios での制御を行っています。

* SIGINTを有効にしているため Ctrl+C の入力で終了します。
* 読み出し時に `feof(stdin)` により EOF が検出されたときに `mwx_exit()` を呼び出します。



### プラットフォーム特有の実装

* `mwx_stdio.cpp`中の`millis()`関数(システム時間をミリ秒で取得する)
* `mwx_serial_con.hpp`中のtermios実装(ノンブロックの読み込みなどを行うため)
* `mwx_stdio.cpp`中の`m32TickCount_ms`(この変数はライブラリのいくつかの箇所で読み出されます)



### パーサーを動作させるための最小限の実装

* `millis()`は0を返すだけの関数とする。タイムスタンプ値が記録・更新されません。
* `u32TickCount_ms`を更新しない。タイムアウト処理が動作しなくなります。
* `mwx::serial_con`による実装は使用しない。パーサーライブラリを動作させるために`mwx::steream`派生のクラスは必要ありません。入力手段から得た1バイトを、`parse(uint8_t)`メソッドに投入することで解釈を進めるインタフェースになっています。
* ソースlibsrc/mwx_stdio.cppには、`main()`関数があり`setup()`や`loop()`もここから呼び出されます。このソースファイルの記述をターゲット環境に合わせて調整します。